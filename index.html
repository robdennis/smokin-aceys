<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Game Strategy Simulator</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Plotly.js for charting -->
    <script src="https://cdn.plot.ly/plotly-2.33.0.min.js"></script>
    <style>
        /* Custom styles for better UX */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background */
            color: #d1d5db; /* Light text */
        }
        .card {
            background-color: #1f2937;
            border: 1px solid #374151;
            border-radius: 0.75rem;
            padding: 1.5rem;
        }
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            border: 1px solid transparent;
        }
        .btn-primary {
            background-color: #3b82f6;
            color: white;
        }
        .btn-primary:hover {
            background-color: #2563eb;
        }
        .btn-secondary {
            background-color: #4b5563;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #374151;
        }
        .btn-danger {
            background-color: #ef4444;
            color: white;
        }
        .btn-danger:hover {
            background-color: #dc2626;
        }
        input, select {
            background-color: #374151;
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            padding: 0.5rem;
            width: 100%;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px #1e40af;
        }
        details > summary {
            cursor: pointer;
            font-size: 1.25rem;
            font-weight: 600;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
        }
        details > summary:hover {
            background-color: #374151;
        }
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        .modal-content {
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-screen-2xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white">Card Game Strategy Simulator</h1>
            <p class="text-lg text-gray-400 mt-2">Model and analyze betting strategies for the 'Between the Sheets' card game.</p>
        </header>

        <div id="main-grid" class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Panel: Configuration -->
            <div id="config-panel" class="lg:col-span-1 flex flex-col gap-8">
                <!-- Game Settings -->
                <div id="game-settings-card" class="card">
                    <h2 class="text-2xl font-bold mb-4 border-b border-gray-600 pb-2">Game Settings</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="ante-amount" class="block font-medium mb-1">Ante Amount ($)</label>
                            <input type="number" id="ante-amount" value="0.20" min="0.01" step="0.01">
                        </div>
                        <div>
                            <label for="starting-pot" class="block font-medium mb-1">Extra Starting Pot ($)</label>
                            <input type="number" id="starting-pot" value="0" min="0" step="0.01">
                        </div>
                        <h3 class="font-bold pt-2">Game End Conditions</h3>
                        <div>
                            <label for="min-total-bets" class="block font-medium mb-1">Min Total Bets Made</label>
                            <input type="number" id="min-total-bets" value="6" min="1">
                        </div>
                        <div>
                            <label for="min-pot-clear-value" class="block font-medium mb-1">Min Pot Size on Clear ($)</label>
                            <input type="number" id="min-pot-clear-value" value="2" min="0" step="0.01">
                        </div>
                        <div class="pt-2">
                             <label class="flex items-center">
                                <input type="checkbox" id="show-live-deck" class="w-auto mr-2">
                                Show Live Deck
                            </label>
                             <label class="flex items-center mt-1">
                                <input type="checkbox" id="show-live-turn" class="w-auto mr-2" checked>
                                Show Live Turn Details
                            </label>
                        </div>
                        <div class="flex gap-4 pt-4">
                             <button id="import-config-btn" class="btn btn-secondary flex-1">Import Config</button>
                             <button id="export-config-btn" class="btn btn-secondary flex-1">Export Config</button>
                             <input type="file" id="import-file-input" class="hidden" accept=".json">
                        </div>
                    </div>
                </div>

                <!-- Players -->
                <div class="card">
                    <h2 class="text-2xl font-bold mb-4 border-b border-gray-600 pb-2">Players</h2>
                    <div id="player-list" class="space-y-3"></div>
                    <button id="add-player-btn" class="btn btn-primary w-full mt-4">Add New Player</button>
                </div>
            </div>

            <!-- Right Panel: Simulation & Results -->
            <div id="results-panel" class="lg:col-span-2 flex flex-col gap-8">
                <!-- Simulation Controls -->
                <div class="card">
                     <h2 class="text-2xl font-bold mb-2 border-b border-gray-600 pb-2">Simulation Controls</h2>
                     <div class="flex flex-col md:flex-row gap-2 items-center">
                        <div class="w-full md:w-auto flex-grow">
                             <label for="simulation-count" class="block font-medium mb-1">Number of Games to Simulate</label>
                             <input type="number" id="simulation-count" value="100" min="1" class="w-full">
                        </div>
                        <div class="w-full md:w-auto pt-0 md:pt-7">
                            <button id="start-simulation-btn" class="btn btn-primary w-full">Start Simulation</button>
                        </div>
                        <div class="w-full md:w-auto pt-0 md:pt-7">
                             <button id="stop-simulation-btn" class="btn btn-danger w-full hidden">Stop Simulation</button>
                        </div>
                         <div id="next-turn-btn-container" class="w-full md:w-auto pt-0 md:pt-7 hidden">
                             <button id="next-turn-btn" class="btn btn-secondary w-full">Next Turn</button>
                         </div>
                        <div id="toggle-config-btn-container" class="w-full md:w-auto pt-0 md:pt-7 hidden">
                            <button id="toggle-config-btn" class="btn btn-secondary w-full">Show Config</button>
                        </div>
                     </div>
                     <div id="progress-container" class="mt-2 hidden">
                        <div class="flex justify-between mb-1">
                            <span id="progress-text" class="text-base font-medium text-blue-400">Running...</span>
                            <span id="progress-percentage" class="text-sm font-medium text-blue-400">0%</span>
                        </div>
                        <div class="w-full bg-gray-700 rounded-full h-2.5">
                            <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                        </div>
                        <div class="flex justify-between text-sm text-gray-400 mt-2">
                            <span id="elapsed-time-text">Elapsed: 0s</span>
                            <span id="eta-text">ETA: N/A</span>
                        </div>
                     </div>
                </div>
                <!-- Results -->
                <div id="results-container" class="card hidden">
                     <h2 class="text-2xl font-bold mb-4 border-b border-gray-600 pb-2">Simulation Results</h2>
                     <div class="space-y-6">
                        <details id="overall-stats-details" open>
                            <summary>Overall Game Statistics</summary>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 pt-4">
                                <div class="md:col-span-2 flex">
                                    <div id="live-deck-display" class="w-1/5 pr-4 overflow-y-auto text-xs hidden"></div>
                                    <div id="live-turn-display" class="flex-grow pr-4 text-xs hidden h-80 overflow-y-auto bg-gray-800 p-2 rounded-md"></div>
                                    <div id="pot-size-chart" class="flex-grow h-80"></div>
                                </div>
                                 <div id="player-pot-history-container" class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <!-- Player pot history heatmaps go here -->
                                </div>
                                <div class="md:col-span-2 overflow-x-auto pt-4">
                                    <h3 class="text-xl font-bold mb-2 pl-2">Spread Analysis</h3>
                                    <table class="w-full text-sm text-left">
                                        <thead class="text-xs uppercase bg-gray-700">
                                            <tr>
                                                <th class="px-2 py-2 align-bottom border-r border-gray-600">Spread</th>
                                                <th colspan="5" class="px-2 py-2 text-center border-b border-r border-gray-600">Measured</th>
                                                <th colspan="5" class="px-2 py-2 text-center border-b border-r border-gray-600">Contextual</th>
                                                <th colspan="5" class="px-2 py-2 text-center border-b border-gray-600">Theoretical</th>
                                            </tr>
                                            <tr>
                                                <th class="px-2 py-2 border-r border-gray-600"></th>
                                                <th class="px-2 py-2 text-center">Occur %</th>
                                                <th class="px-2 py-2 text-center">W%</th>
                                                <th class="px-2 py-2 text-center">L%</th>
                                                <th class="px-2 py-2 text-center">DL%</th>
                                                <th class="px-2 py-2 text-center">EV</th>

                                                <th class="px-2 py-2 text-center">Occur %</th>
                                                <th class="px-2 py-2 text-center">W%</th>
                                                <th class="px-2 py-2 text-center">L%</th>
                                                <th class="px-2 py-2 text-center">DL%</th>
                                                <th class="px-2 py-2 text-center">EV</th>

                                                <th class="px-2 py-2 text-center">Occur %</th>
                                                <th class="px-2 py-2 text-center">W%</th>
                                                <th class="px-2 py-2 text-center">L%</th>
                                                <th class="px-2 py-2 text-center">DL%</th>
                                                <th class="px-2 py-2 text-center">EV</th>
                                            </tr>
                                        </thead>
                                        <tbody id="spread-analysis-table">
                                            <!-- Rows will be generated by JS -->
                                        </tbody>
                                    </table>
                                </div>
                                <div id="game-length-heatmap-container" class="h-96">
                                    <div id="game-length-heatmap" class="h-96"></div>
                                </div>
                                <div id="antes-made-heatmap-container" class="h-96">
                                    <div id="antes-made-heatmap" class="h-96"></div>
                                </div>
                                <div id="shuffles-heatmap-container" class="h-96">
                                    <div id="shuffles-heatmap" class="h-96"></div>
                                </div>
                                <div id="game-time-heatmap-container" class="h-96">
                                    <div id="game-time-heatmap" class="h-96"></div>
                                </div>
                            </div>
                        </details>
                        <details id="player-stats-details">
                            <summary>Player Statistics</summary>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 pt-4">
                                <div id="gave-up-heatmap-container" class="h-96 hidden">
                                    <div id="gave-up-heatmap" class="h-96"></div>
                                </div>
                                <div id="player-win-loss-container" class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <!-- Player heatmaps go here -->
                                </div>
                                <div id="player-bet-amount-container" class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <!-- Player bet amount heatmaps go here -->
                                </div>
                            </div>
                        </details>
                     </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Player Editor Modal -->
    <div id="player-modal" class="modal-backdrop hidden">
        <div class="card modal-content">
            <h2 id="modal-title" class="text-2xl font-bold mb-4">Add Player</h2>
            <div class="space-y-4">
                <input type="hidden" id="player-id">
                <div>
                    <label for="player-name" class="block font-medium mb-1">Player Name</label>
                    <input type="text" id="player-name" placeholder="e.g., Player 1">
                </div>
                <!-- Financials -->
                <h3 class="font-bold pt-2 border-t border-gray-600">Financials</h3>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="start-money" class="block font-medium mb-1">Starting Money ($)</label>
                        <input type="number" id="start-money" value="100" step="0.01">
                    </div>
                    <div>
                        <label for="stop-loss" class="block font-medium mb-1">Stop-Loss Threshold ($) (optional)</label>
                        <input type="number" id="stop-loss" placeholder="e.g., -50" step="0.01">
                    </div>
                 </div>
                 <h4 class="font-semibold pt-2">Re-buy Strategy</h4>
                 <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div>
                        <label for="rebuy-strategy" class="block font-medium mb-1">Type</label>
                        <select id="rebuy-strategy">
                            <option value="cover_bet">Cover Bet Needed</option>
                            <option value="fixed_amount">Fixed Amount</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                     <div id="rebuy-amount-container">
                        <label for="buy-in-amount" class="block font-medium mb-1">Re-buy Amount ($)</label>
                        <input type="number" id="buy-in-amount" value="50" min="0.01" step="0.01">
                    </div>
                     <div>
                        <label for="buy-in-count" class="block font-medium mb-1"># of Re-buys</label>
                        <input type="number" id="buy-in-count" value="1" min="0">
                        <label><input type="checkbox" id="buy-in-unlimited" class="w-auto mt-1"> Unlimited</label>
                    </div>
                 </div>

                <!-- Card Counting -->
                <h3 class="font-bold pt-4 border-t border-gray-600">Card Counting Strategy</h3>
                <div>
                    <label for="card-counting" class="block font-medium mb-1">Awareness of remaining cards</label>
                    <select id="card-counting">
                        <option value="none">None (Assumes full deck)</option>
                        <option value="full">Full (Perfect knowledge of discard pile)</option>
                        <option value="custom">Custom (Tracks specific ranks)</option>
                    </select>
                </div>
                <div id="custom-ranks-container" class="hidden">
                    <label for="custom-ranks" class="block font-medium mb-1">Ranks to track (comma-separated: 2-10, J, Q, K, A)</label>
                    <input type="text" id="custom-ranks" placeholder="e.g., A, K, Q">
                </div>

                <!-- Betting Strategy -->
                <h3 class="font-bold pt-4 border-t border-gray-600">Betting Strategy per Spread</h3>
                <p class="text-sm text-gray-400">Define the bet for each possible spread between two cards. Spread 0 is two cards of the same rank (e.g., 5-5), spread 1 is consecutive (e.g., 5-6), up to spread 12 (Ace-2).</p>
                <div class="overflow-x-auto">
                    <table class="w-full text-sm text-left">
                        <thead class="text-xs uppercase bg-gray-700">
                            <tr>
                                <th class="px-4 py-2">Spread</th>
                                <th class="px-4 py-2">Strategy</th>
                                <th class="px-4 py-2">Value</th>
                                <th class="px-2 py-2 text-center">Theo. Occur %</th>
                                <th class="px-2 py-2 text-center">Theo. Win%</th>
                                <th class="px-2 py-2 text-center">Theo. Loss%</th>
                                <th class="px-2 py-2 text-center">Theo. D-Loss%</th>
                                <th class="px-2 py-2 text-center">Theo. EV</th>
                            </tr>
                        </thead>
                        <tbody id="betting-strategy-table">
                            <!-- Rows will be generated by JS -->
                        </tbody>
                    </table>
                </div>

                <div class="flex justify-end gap-4 pt-4">
                    <button id="cancel-player-btn" class="btn btn-secondary">Cancel</button>
                    <button id="save-player-btn" class="btn btn-primary">Save Player</button>
                </div>
            </div>
        </div>
    </div>

    <!-- This script tag contains the simulation logic that will be run in a Web Worker -->
    <script id="simulator-worker" type="javascript/worker">
        // --- CORE GAME LOGIC ---
        const SUITS = ['H', 'D', 'C', 'S'];
        const RANKS = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };

        class Deck {
            constructor() { this.cards = []; this.discardPile = []; this.createDeck(); this.shuffle(); }
            createDeck() { this.cards = []; for (const suit of SUITS) for (const rank in RANKS) this.cards.push({ rank: RANKS[rank], suit, name: `${rank}${suit}` }); }
            shuffle() {
                for (let i = this.cards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
                }
            }
            draw(count = 1) { const d = this.cards.splice(-count); this.discardPile.push(...d); return d; }
            reset() { this.createDeck(); this.shuffle(); this.discardPile = []; }
        }

        // --- SIMULATION LOGIC ---
        let simulationState = {};
        let isPaused = false;
        let turnQueue = [];

        self.onmessage = function(e) {
            const { type, config } = e.data;
            switch (type) {
                case 'start':
                    isPaused = false;
                    turnQueue = [];
                    runSimulation(config);
                    break;
                case 'stop': // This now means pause
                    isPaused = true;
                    self.postMessage({ type: 'paused' });
                    break;
                case 'resume':
                    isPaused = false;
                    self.postMessage({ type: 'resumed' });
                    // Unblock the gameLoop by resolving the current pending step
                    if (turnQueue.length > 0) {
                        const resolver = turnQueue.shift();
                        resolver();
                    }
                    break;
                case 'nextTurn':
                    if (turnQueue.length > 0) {
                        const resolver = turnQueue.shift();
                        resolver(); // This will resolve the promise inside gameStep
                    }
                    break;
                 case 'terminate':
                    isPaused = true; // Effectively stops the simulation
                    self.close();
                    break;
            }
        };

        function gameStep() {
            return new Promise(resolve => {
                if (isPaused) {
                    turnQueue.push(resolve);
                    self.postMessage({ type: 'readyForNextTurn' });
                } else {
                    // Yield to the event loop to allow other messages (like 'stop') to be processed.
                    setTimeout(resolve, 0);
                }
            });
        }

        function runSimulation(config) {
            const { players: playerConfigs, game: gameConfig, simulationCount, showLiveDeck, showLiveTurn } = config;
            simulationState.config = config;
            simulationState.currentGameIndex = 0;

            const theoreticalStats = calculateTheoreticalStats();
            self.postMessage({ type: 'ready', data: { theoreticalStats } });

            gameLoop();
        }

        async function gameLoop() {
            for (let i = simulationState.currentGameIndex; i < simulationState.config.simulationCount; i++) {

                simulationState.currentGameIndex = i;

                const startTime = performance.now();
                const deck = new Deck();
                if (simulationState.config.showLiveDeck) {
                    self.postMessage({ type: 'deckShuffled', data: { deck: [...deck.cards] } });
                }
                let pot = simulationState.config.game.startingPot;

                // Correctly deep-copy players for the new game, preserving Infinity
                let playersAsJson = JSON.stringify(simulationState.config.players, (k,v) => v === Infinity ? "Infinity" : v);
                let playersConfigForGame = JSON.parse(playersAsJson, (k, v) => v === "Infinity" ? Infinity : v);
                let players = playersConfigForGame.map(p => ({ ...p, money: p.startMoney, isActive: true, buyInUsed: 0, rebuyAmountUsed: 0}));

                let playerContributions = players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});

                let currentGameStats = {
                    gameNum: i + 1, potHistory: [], playerPotHistory: {}, spreads: {}, playerBets: {},
                    length: 0, shuffles: 0, antesMade: 0, playersGaveUp: 0,
                    playerFinalFinancials: {},
                    aggregatedContextualOccurrences: Array(13).fill(0),
                    totalHandsForContextual: 0
                };
                players.forEach(p => {
                    currentGameStats.playerPotHistory[p.id] = [];
                    currentGameStats.playerBets[p.id] = [];
                });

                function handleRebuyIfNeeded(player, amountNeeded, gameLog) {
                     while (player.money < amountNeeded) {
                        if (!player.rebuy || player.rebuy.strategy === 'none' || (player.rebuy.count !== Infinity && player.buyInUsed >= player.rebuy.count)) {
                            break;
                        }

                        let rebuyAmount = player.rebuy.strategy === 'cover_bet' ? amountNeeded - player.money : player.rebuy.amount;
                        if (rebuyAmount <= 0) rebuyAmount = player.rebuy.amount; // Fallback for cover_bet if money is negative

                        player.money += rebuyAmount;
                        player.rebuyAmountUsed += rebuyAmount;
                        if (player.rebuy.count !== Infinity) {
                            player.buyInUsed++;
                        }
                        gameLog.push({type: 'rebuy', playerName: player.name, amount: rebuyAmount, remaining: player.rebuy.count !== Infinity ? player.rebuy.count - player.buyInUsed : 'Unlimited'});
                    }
                }

                function anteUp(gameLog) {
                    let activePlayers = players.filter(p => p.isActive);
                    if (activePlayers.length === 0) return false;
                    activePlayers.forEach(player => {
                        handleRebuyIfNeeded(player, simulationState.config.game.ante, gameLog);
                        if (player.money >= simulationState.config.game.ante) {
                            player.money -= simulationState.config.game.ante;
                            pot += simulationState.config.game.ante;
                            playerContributions[player.id] += simulationState.config.game.ante;
                        } else {
                            if(player.isActive) { player.isActive = false; currentGameStats.playersGaveUp++; }
                        }
                    });
                    currentGameStats.antesMade++;
                    return players.some(p => p.isActive);
                }


                let gameLogForTurn = [];
                if (!anteUp(gameLogForTurn)) {
                    // end game if no one can ante
                }

                let currentPlayerIndex = -1;
                let gameRunning = true;
                let consecutiveZeroBets = 0;

                while (gameRunning) {

                    currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                    let currentPlayer = players[currentPlayerIndex];

                    if (!currentPlayer.isActive) {
                        if (players.every(p => !p.isActive)) { gameRunning = false; break; }
                        continue;
                    }

                    if (deck.cards.length < 3) {
                        deck.reset();
                        currentGameStats.shuffles++;
                        if (simulationState.config.showLiveDeck) {
                            self.postMessage({ type: 'deckShuffled', data: { deck: [...deck.cards] } });
                        }
                    }

                    const contextualOccurrences = calculateContextualOccurrence(deck.cards);
                    currentGameStats.totalHandsForContextual++;
                    contextualOccurrences.forEach((p, i) => currentGameStats.aggregatedContextualOccurrences[i] += p);

                    const [card1, card2] = deck.draw(2);
                    const highRank = Math.max(card1.rank, card2.rank);
                    const lowRank = Math.min(card1.rank, card2.rank);
                    const spread = highRank - lowRank - 1;
                    const userSpread = spread + 1;

                    const betDecision = getPlayerBet(currentPlayer, spread, pot, simulationState.config.game.ante, deck);
                    const betAmount = Math.max(betDecision.bet, 0); // Allow zero bets

                    let turnDetails = null;

                    await gameStep();
                    // This part happens right before the bet result is known
                    turnDetails = {
                        playerName: currentPlayer.name,
                        card1, card2, spread, betAmount,
                        card3: null, outcome: 'pending',
                        log: gameLogForTurn,
                        playerMoneyBefore: currentPlayer.money
                    };
                    const { spreads, potHistory, playerPotHistory, ...restOfStats } = currentGameStats;
                    const tickData = { ...restOfStats, latestPot: pot, spreads, playerPots: playerContributions, playerBets: currentGameStats.playerBets };
                    if (simulationState.config.showLiveDeck) tickData.deck = deck.cards;
                    if (simulationState.config.showLiveTurn) tickData.turnDetails = turnDetails;
                    self.postMessage({ type: 'tick', data: tickData });
                    gameLogForTurn = []; // Reset log for next turn

                    await gameStep();
                    // This part happens right after the bet result is known
                    if (betAmount > 0) {
                        consecutiveZeroBets = 0;
                    } else {
                        consecutiveZeroBets++;
                    }

                    if (consecutiveZeroBets > players.length * 5) { // Game stall detection
                        gameRunning = false;
                    }

                    if(gameRunning) {
                        currentGameStats.length++;

                        handleRebuyIfNeeded(currentPlayer, betAmount, gameLogForTurn);

                        if (betAmount > 0 && currentPlayer.money >= betAmount) {
                            currentGameStats.playerBets[currentPlayer.id].push(betAmount);
                            currentPlayer.money -= betAmount;

                            const contextualOutcomes = calculateContextualOutcomes(deck);
                            const [card3] = deck.draw(1);
                            turnDetails.card3 = card3;

                            let outcome;
                            if (card3.rank === highRank || card3.rank === lowRank) {
                                outcome = 'dloss';
                                pot += betAmount * 2;
                                playerContributions[currentPlayer.id] += betAmount * 2;
                            }
                            else if (card3.rank > lowRank && card3.rank < highRank) {
                                outcome = 'win';
                                const winnings = betAmount;
                                pot -= winnings;
                                currentPlayer.money += betAmount + winnings;
                                playerContributions[currentPlayer.id] -= winnings;

                                if (!currentGameStats.spreads[userSpread]) currentGameStats.spreads[userSpread] = {};
                                currentGameStats.spreads[userSpread].maxWin = Math.max(currentGameStats.spreads[userSpread].maxWin || 0, winnings / simulationState.config.game.ante);
                            } else {
                                outcome = 'loss';
                                pot += betAmount;
                                playerContributions[currentPlayer.id] += betAmount;
                            }

                            turnDetails.outcome = outcome;

                            if (!currentGameStats.spreads[userSpread]) currentGameStats.spreads[userSpread] = { occurrences: 0, wins: 0, losses: 0, dlosses: 0, sumEVContextual: 0, sumCtxWin:0, sumCtxLoss:0, sumCtxDloss:0 };
                            const s = currentGameStats.spreads[userSpread];
                            s.occurrences++;
                            s[outcome + 'es'] = (s[outcome + 'es'] || 0) + 1;
                            s.sumCtxWin += contextualOutcomes.win;
                            s.sumCtxLoss += contextualOutcomes.loss;
                            s.sumCtxDloss += contextualOutcomes.dloss;

                            const ev_contextual = calculateEVsForBet(betAmount, spread, deck, deck.cards).observed;
                            s.sumEVContextual += ev_contextual;
                        } else {
                            if (betAmount > 0) { // Player was supposed to bet but couldn't cover it
                                currentPlayer.isActive = false;
                                currentGameStats.playersGaveUp++;
                                turnDetails.outcome = 'quit';
                            } else { // A bet of 0 is a legal pass
                                turnDetails.outcome = 'pass';
                            }
                        }

                        currentGameStats.potHistory.push(pot);
                        players.forEach(p => currentGameStats.playerPotHistory[p.id].push(playerContributions[p.id]));

                        if (currentPlayer.stopLoss !== null && (currentPlayer.startMoney + currentPlayer.rebuyAmountUsed - currentPlayer.money) > currentPlayer.stopLoss && currentPlayer.isActive) {
                            gameLogForTurn.push({type: 'stoploss', playerName: currentPlayer.name, threshold: currentPlayer.stopLoss});
                            currentGameStats.playersGaveUp++; currentPlayer.isActive = false;
                        }


                        if (pot <= 0) {
                            if (currentGameStats.length >= simulationState.config.game.minTotalBets || Math.abs(pot) >= simulationState.config.game.minPotClearValue) gameRunning = false;
                            else {
                                if(!anteUp(gameLogForTurn)) gameRunning = false;
                                playerContributions = players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                                players.forEach(p => currentGameStats.playerPotHistory[p.id] = []);
                            }
                        }

                        if (players.every(p => !p.isActive)) gameRunning = false;

                        const { spreads: finalSpreads, potHistory: finalPotHistory, playerPotHistory: finalPlayerPotHistory, ...finalRestOfStats } = currentGameStats;
                        const finalTickData = { ...finalRestOfStats, latestPot: pot, spreads: finalSpreads, playerPots: playerContributions, playerBets: currentGameStats.playerBets };
                        if (simulationState.config.showLiveDeck) finalTickData.deck = deck.cards;
                        if (simulationState.config.showLiveTurn) finalTickData.turnDetails = turnDetails;
                        self.postMessage({ type: 'tick', data: finalTickData });
                    }
                }

                currentGameStats.duration = (performance.now() - startTime) / 1000;
                players.forEach(p => {
                    currentGameStats.playerFinalFinancials[p.id] = { finalMoney: p.money, rebuyAmountUsed: p.rebuyAmountUsed, startMoney: p.startMoney };
                });

                self.postMessage({ type: 'gameComplete', data: { finalStats: currentGameStats, progress: (i + 1) / simulationState.config.simulationCount, gameNum: i + 1, totalGames: simulationState.config.simulationCount }});
            }
            self.postMessage({ type: 'complete' });
        }

        function getPlayerBet(player, spread, pot, ante, deck) {
            const strategy = player.bettingStrategy[spread + 1];
            let bet = 0;

            let perceivedDeck = [...deck.cards];
            if (player.cardCounting === 'none') {
                perceivedDeck = []; for (const suit of SUITS) for (const rank in RANKS) perceivedDeck.push({ rank: RANKS[rank], suit });
            } else if (player.cardCounting === 'custom') {
                const customRanksToTrack = player.customRanks.map(r => RANKS[r.toUpperCase()]).filter(Boolean);
                const knownDiscards = deck.discardPile.filter(c => customRanksToTrack.includes(c.rank));
                const fullDeckCards = []; for (const suit of SUITS) for (const rank in RANKS) fullDeckCards.push({ rank: RANKS[rank], suit, name: `${rank}${suit}` });
                perceivedDeck = fullDeckCards.filter(card => !knownDiscards.some(d => d.name === card.name));
            }

            switch (strategy.type) {
                case 'min': bet = ante; break;
                case 'ante': bet = ante * strategy.value; break;
                case 'pot': bet = pot * (strategy.value / 100); break;
            }

            bet = Math.max(0, Math.min(bet, pot));
            bet = Math.round(bet);

            const evs = calculateEVsForBet(bet, spread, deck, perceivedDeck);
            return { bet, evs };
        }

        function calculateEVsForBet(betAmount, spread, actualDeck, perceivedDeck) {
            const lastTwoCards = actualDeck.discardPile.slice(-2);
            if (lastTwoCards.length < 2) return { theoretical: 0, observed: 0 };
            const highRank = Math.max(lastTwoCards[0].rank, lastTwoCards[1].rank);
            const lowRank = Math.min(lastTwoCards[0].rank, lastTwoCards[1].rank);

            function calculate(deck, bet) {
                if (bet === 0) return 0;
                let wins = 0, losses = 0, dlosses = 0;
                deck.forEach(card => {
                    if (card.rank === highRank || card.rank === lowRank) dlosses++;
                    else if (card.rank > lowRank && card.rank < highRank) wins++;
                    else losses++;
                });
                const total = deck.length;
                if(total === 0) return 0;
                const pWin = wins / total, pLoss = losses / total, pDLoss = dlosses / total;
                return (pWin * bet) - (pLoss * bet) - (pDLoss * 2 * bet);
            }

            const theoreticalDeck = [];
            for (const suit of SUITS) for (const rank in RANKS) {
                const card = { rank: RANKS[rank], suit, name: `${rank}${suit}` };
                if (!lastTwoCards.some(c => c.name === card.name)) theoreticalDeck.push(card);
            }

            return { theoretical: calculate(theoreticalDeck, betAmount), observed: calculate(perceivedDeck, betAmount) };
        }

        function calculateContextualOccurrence(deck) {
            const occurrences = Array(13).fill(0);
            const n = deck.length;
            if (n < 2) return occurrences;
            const totalPairs = n * (n - 1) / 2;
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const spread = Math.abs(deck[i].rank - deck[j].rank);
                    if (spread > 0 && spread <= 13) {
                        occurrences[spread-1]++;
                    }
                }
            }
            return occurrences.map(count => (count / totalPairs) * 100);
        }

        function calculateContextualOutcomes(deck) {
            const lastTwoCards = deck.discardPile.slice(-2);
            const highRank = Math.max(lastTwoCards[0].rank, lastTwoCards[1].rank);
            const lowRank = Math.min(lastTwoCards[0].rank, lastTwoCards[1].rank);
            let wins = 0, losses = 0, dlosses = 0;
            deck.cards.forEach(card => {
                if (card.rank === highRank || card.rank === lowRank) dlosses++;
                else if (card.rank > lowRank && card.rank < highRank) wins++;
                else losses++;
            });
            const total = deck.cards.length;
            return {
                win: total > 0 ? (wins/total)*100 : 0,
                loss: total > 0 ? (losses/total)*100 : 0,
                dloss: total > 0 ? (dlosses/total)*100 : 0
            };
        }

        function calculateTheoreticalStats() {
            const stats = { occurrence: [], outcomes: [], ev: [] };
            const totalPairs = (52 * 51) / 2;
            for (let userSpread = 0; userSpread <= 12; userSpread++) {
                let pairCount = 0;
                if (userSpread === 0) pairCount = 13 * (4 * 3 / 2);
                else { const rankDistance = userSpread; pairCount = (13 - rankDistance) * 4 * 4; }
                stats.occurrence[userSpread] = (pairCount / totalPairs) * 100;

                let win_ranks = userSpread > 0 ? userSpread - 1 : 0;
                let dloss_ranks = userSpread > 0 ? 2 : 1;
                let loss_ranks = 13 - win_ranks - dloss_ranks;
                stats.outcomes[userSpread] = { win: (win_ranks/13)*100, loss: (loss_ranks/13)*100, dloss: (dloss_ranks/13)*100 };
                stats.ev[userSpread] = (win_ranks/13 * 1) - (loss_ranks/13 * 1) - (dloss_ranks/13 * 2);
            }
            return stats;
        }
    </script>


    <script type="module">
        // --- UI & STATE MANAGEMENT ---
        let players = [];
        let simulationWorker = null;
        let simulationTimer = null;
        let simulationStartTime = 0;
        const simulationTimings = [];
        let isSimulationPaused = false;

        let allCompletedGamesData = [];
        let currentLiveGameData = null;
        let currentLiveGamePotHistory = [];
        let currentLivePlayerPotHistory = {};
        let currentLivePlayerBets = {};
        let theoreticalStats = null;
        let playerColors = {};


        function calculateTheoreticalStatsForUI() {
            const stats = [];
            for (let userSpread = 0; userSpread <= 12; userSpread++) {
                let win_ranks = userSpread > 0 ? userSpread - 1 : 0;
                let dloss_ranks = userSpread > 0 ? 2 : 1;
                let loss_ranks = 13 - win_ranks - dloss_ranks;
                let ev = (win_ranks/13 * 1) - (loss_ranks/13 * 1) - (dloss_ranks/13 * 2);
                 let pairCount = 0;
                const totalPairs = (52 * 51) / 2;
                if (userSpread === 0) pairCount = 13 * (4 * 3 / 2);
                else { const rankDistance = userSpread; pairCount = (13 - rankDistance) * 4 * 4; }

                stats[userSpread] = {
                    win: (win_ranks/13) * 100, loss: (loss_ranks/13) * 100,
                    dloss: (dloss_ranks/13) * 100, ev: ev,
                    occur: (pairCount / totalPairs) * 100
                };
            }
            return stats;
        }

        const DOM = {
            mainGrid: document.getElementById('main-grid'),
            configPanel: document.getElementById('config-panel'),
            resultsPanel: document.getElementById('results-panel'),
            toggleConfigBtnContainer: document.getElementById('toggle-config-btn-container'),
            toggleConfigBtn: document.getElementById('toggle-config-btn'),
            playerList: document.getElementById('player-list'),
            addPlayerBtn: document.getElementById('add-player-btn'),
            playerModal: document.getElementById('player-modal'),
            modalTitle: document.getElementById('modal-title'),
            savePlayerBtn: document.getElementById('save-player-btn'),
            cancelPlayerBtn: document.getElementById('cancel-player-btn'),
            playerId: document.getElementById('player-id'),
            playerName: document.getElementById('player-name'),
            startMoney: document.getElementById('start-money'),
            stopLoss: document.getElementById('stop-loss'),
            rebuyStrategy: document.getElementById('rebuy-strategy'),
            rebuyAmountContainer: document.getElementById('rebuy-amount-container'),
            buyInAmount: document.getElementById('buy-in-amount'),
            buyInCount: document.getElementById('buy-in-count'),
            buyInUnlimited: document.getElementById('buy-in-unlimited'),
            cardCounting: document.getElementById('card-counting'),
            customRanksContainer: document.getElementById('custom-ranks-container'),
            customRanks: document.getElementById('custom-ranks'),
            bettingStrategyTable: document.getElementById('betting-strategy-table'),
            startSimBtn: document.getElementById('start-simulation-btn'),
            stopSimBtn: document.getElementById('stop-simulation-btn'),
            nextTurnBtn: document.getElementById('next-turn-btn'),
            nextTurnBtnContainer: document.getElementById('next-turn-btn-container'),
            simCountInput: document.getElementById('simulation-count'),
            progressContainer: document.getElementById('progress-container'),
            progressBar: document.getElementById('progress-bar'),
            progressText: document.getElementById('progress-text'),
            progressPercentage: document.getElementById('progress-percentage'),
            elapsedTimeText: document.getElementById('elapsed-time-text'),
            etaText: document.getElementById('eta-text'),
            resultsContainer: document.getElementById('results-container'),
            anteAmount: document.getElementById('ante-amount'),
            startingPot: document.getElementById('starting-pot'),
            minTotalBets: document.getElementById('min-total-bets'),
            minPotClearValue: document.getElementById('min-pot-clear-value'),
            showLiveDeck: document.getElementById('show-live-deck'),
            showLiveTurn: document.getElementById('show-live-turn'),
            liveDeckDisplay: document.getElementById('live-deck-display'),
            liveTurnDisplay: document.getElementById('live-turn-display'),
            importConfigBtn: document.getElementById('import-config-btn'),
            exportConfigBtn: document.getElementById('export-config-btn'),
            importFileInput: document.getElementById('import-file-input'),
            spreadAnalysisTable: document.getElementById('spread-analysis-table'),
            playerWinLossContainer: document.getElementById('player-win-loss-container'),
            playerBetAmountContainer: document.getElementById('player-bet-amount-container'),
            playerPotHistoryContainer: document.getElementById('player-pot-history-container'),
            gaveUpHeatmapContainer: document.getElementById('gave-up-heatmap-container'),
            gameLengthHeatmapContainer: document.getElementById('game-length-heatmap-container'),
            antesMadeHeatmapContainer: document.getElementById('antes-made-heatmap-container'),
            shufflesHeatmapContainer: document.getElementById('shuffles-heatmap-container'),
            gameTimeHeatmapContainer: document.getElementById('game-time-heatmap-container'),
            playerStatsDetails: document.getElementById('player-stats-details'),
        };

        const elementsToHideDuringSim = [
            'game-length-heatmap-container',
            'antes-made-heatmap-container',
            'shuffles-heatmap-container',
            'game-time-heatmap-container',
            'player-stats-details',
            'player-pot-history-container'
        ];


        function initialize() {
            setupEventListeners();
            createBettingStrategyTable();
            addDefaultPlayers();
            updatePlayerColors();
            renderPlayerList();
        }

        function setupEventListeners() {
            DOM.addPlayerBtn.addEventListener('click', () => openPlayerModal());
            DOM.savePlayerBtn.addEventListener('click', savePlayer);
            DOM.cancelPlayerBtn.addEventListener('click', closePlayerModal);
            DOM.buyInUnlimited.addEventListener('change', (e) => {
                DOM.buyInCount.disabled = e.target.checked;
            });
            DOM.rebuyStrategy.addEventListener('change', (e) => {
                const strategy = e.target.value;
                DOM.rebuyAmountContainer.classList.toggle('hidden', strategy === 'none');
                DOM.buyInCount.closest('div').classList.toggle('hidden', strategy === 'none');
            });
            DOM.cardCounting.addEventListener('change', (e) => {
                DOM.customRanksContainer.classList.toggle('hidden', e.target.value !== 'custom');
            });
            DOM.startSimBtn.addEventListener('click', startOrResumeSimulation);
            DOM.stopSimBtn.addEventListener('click', stopSimulation);
            DOM.nextTurnBtn.addEventListener('click', () => {
                DOM.nextTurnBtn.disabled = true;
                simulationWorker.postMessage({ type: 'nextTurn' })
            });
            DOM.exportConfigBtn.addEventListener('click', exportConfig);
            DOM.importConfigBtn.addEventListener('click', () => DOM.importFileInput.click());
            DOM.importFileInput.addEventListener('change', importConfig);
            DOM.toggleConfigBtn.addEventListener('click', toggleConfigPanel);
        }

        function toggleConfigPanel() {
            const isVisible = !DOM.configPanel.classList.contains('hidden');
            DOM.configPanel.classList.toggle('hidden');

            if(isVisible) { // it was visible, now it's hidden
                DOM.mainGrid.classList.remove('lg:grid-cols-3');
                DOM.resultsPanel.classList.remove('lg:col-span-2');
                DOM.toggleConfigBtn.textContent = 'Show Config';
            } else { // it was hidden, now it's visible
                DOM.mainGrid.classList.add('lg:grid-cols-3');
                DOM.resultsPanel.classList.add('lg:col-span-2');
                DOM.toggleConfigBtn.textContent = 'Hide Config';
            }

            setTimeout(() => window.dispatchEvent(new Event('resize')), 300);
        }

        function createBettingStrategyTable() {
            const tbody = DOM.bettingStrategyTable;
            const theoreticalStats = calculateTheoreticalStatsForUI();
            tbody.innerHTML = '';
            for (let i = 0; i <= 12; i++) {
                const stats = theoreticalStats[i];
                const row = document.createElement('tr');
                row.className = 'border-b border-gray-700'; row.style.verticalAlign = 'middle';
                row.innerHTML = `
                    <td class="px-4 py-2 font-medium">${i}</td>
                    <td class="px-4 py-2"><select data-spread="${i}" class="strategy-type"><option value="min">Min Bet (Ante)</option><option value="ante"># of Antes</option><option value="pot">% of Pot</option></select></td>
                    <td class="px-4 py-2"><div class="value-container"><input type="number" data-spread="${i}" class="strategy-value" min="0" value="1"></div></td>
                    <td class="px-2 py-2 text-center text-sm">${stats.occur.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center text-sm ${stats.win > 0 ? 'text-green-400' : 'text-gray-400'}">${stats.win.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center text-sm ${stats.loss > 0 ? 'text-yellow-400' : 'text-gray-400'}">${stats.loss.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center text-sm ${stats.dloss > 0 ? 'text-red-400' : 'text-gray-400'}">${stats.dloss.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center text-sm font-mono ${stats.ev >= 0 ? 'text-green-400' : 'text-red-400'}">${stats.ev.toFixed(2)}</td>
                `;
                tbody.appendChild(row);
            }
            tbody.addEventListener('change', (e) => {
                if (e.target.classList.contains('strategy-type')) {
                    e.target.closest('tr').querySelector('.value-container').classList.toggle('hidden', e.target.value === 'min');
                }
            });
        }

        function addDefaultPlayers(){
             const defaultPlayers = [
                {
                    "id": "player-1759696538976",
                    "name": "Nathan",
                    "startMoney": 20,
                    "stopLoss": 50,
                    "rebuy": { "strategy": "cover_bet", "amount": 50, "count": Infinity },
                    "cardCounting": "none", "customRanks": [],
                    "bettingStrategy": [
                        { "type": "min", "value": 1 }, { "type": "min", "value": 1 }, { "type": "min", "value": 1 },
                        { "type": "min", "value": 1 }, { "type": "min", "value": 1 }, { "type": "min", "value": 1 },
                        { "type": "min", "value": 1 }, { "type": "min", "value": 1 }, { "type": "ante", "value": 5 },
                        { "type": "ante", "value": 5 }, { "type": "ante", "value": 5 }, { "type": "ante", "value": 5 },
                        { "type": "ante", "value": 5 }
                    ]
                },
                {
                    "id": "player-1759696864616",
                    "name": "Rob",
                    "startMoney": 20,
                    "stopLoss": 50,
                    "rebuy": { "strategy": "cover_bet", "amount": 50, "count": Infinity },
                    "cardCounting": "none", "customRanks": [],
                    "bettingStrategy": [
                        { "type": "min", "value": 1 }, { "type": "min", "value": 1 }, { "type": "min", "value": 1 },
                        { "type": "min", "value": 1 }, { "type": "min", "value": 1 }, { "type": "min", "value": 1 },
                        { "type": "min", "value": 1 }, { "type": "ante", "value": 1 }, { "type": "pot", "value": 100 },
                        { "type": "pot", "value": 100 }, { "type": "pot", "value": 100 }, { "type": "pot", "value": 100 },
                        { "type": "pot", "value": 100 }
                    ]
                }
            ];
            players.push(...defaultPlayers);
        }

        function updatePlayerColors() {
            const colorPalette = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
            players.forEach((p, i) => {
                if (!playerColors[p.id]) {
                    playerColors[p.id] = colorPalette[Object.keys(playerColors).length % colorPalette.length];
                }
            });
        }

        function openPlayerModal(playerId = null) {
            const isEditing = !!playerId;
            DOM.modalTitle.textContent = isEditing ? 'Edit Player' : 'Add Player';
            DOM.playerId.value = isEditing ? playerId : `player-${Date.now()}`;

            const player = isEditing ? players.find(p => p.id === playerId) : null;
            const rebuy = player?.rebuy || { strategy: 'cover_bet', count: Infinity, amount: 50 };

            DOM.playerName.value = player?.name || '';
            DOM.startMoney.value = player?.startMoney || 100;
            DOM.stopLoss.value = player?.stopLoss || '';

            DOM.rebuyStrategy.value = rebuy.strategy;
            DOM.buyInAmount.value = rebuy.amount;
            DOM.rebuyAmountContainer.classList.toggle('hidden', rebuy.strategy === 'none');
            DOM.buyInCount.closest('div').classList.toggle('hidden', rebuy.strategy === 'none');

            if (rebuy.count === Infinity || rebuy.count === 'Infinity') {
                DOM.buyInUnlimited.checked = true; DOM.buyInCount.disabled = true; DOM.buyInCount.value = 1;
            } else {
                DOM.buyInUnlimited.checked = false; DOM.buyInCount.disabled = false; DOM.buyInCount.value = rebuy.count || 1;
            }

            DOM.cardCounting.value = player?.cardCounting || 'none';
            DOM.customRanks.value = player?.customRanks?.join(', ') || '';
            DOM.customRanksContainer.classList.toggle('hidden', (player?.cardCounting || 'none') !== 'custom');

            const strategies = player?.bettingStrategy || Array(13).fill({ type: 'min', value: 1 });
            for(let i=0; i<=12; i++){
                const row = DOM.bettingStrategyTable.rows[i];
                if (!row) continue;
                row.querySelector(`.strategy-type`).value = strategies[i].type;
                row.querySelector(`.strategy-value`).value = strategies[i].value;
                row.querySelector('.value-container').classList.toggle('hidden', strategies[i].type === 'min');
            }
            DOM.playerModal.classList.remove('hidden');
        }

        function closePlayerModal() {
            DOM.playerModal.classList.add('hidden');
        }

        function savePlayer() {
            const id = DOM.playerId.value;
            const isEditing = players.some(p => p.id === id);

            const player = {
                id,
                name: DOM.playerName.value || `Player ${players.length + 1}`,
                startMoney: parseFloat(DOM.startMoney.value),
                stopLoss: DOM.stopLoss.value ? parseFloat(DOM.stopLoss.value) : null,
                rebuy: {
                    strategy: DOM.rebuyStrategy.value,
                    amount: parseFloat(DOM.buyInAmount.value),
                    count: DOM.buyInUnlimited.checked ? Infinity : parseInt(DOM.buyInCount.value)
                },
                cardCounting: DOM.cardCounting.value,
                customRanks: DOM.customRanks.value.split(',').map(r => r.trim().toUpperCase()).filter(Boolean),
                bettingStrategy: []
            };
            if(player.rebuy.strategy === 'none') player.rebuy.count = 0;

            for (let i = 0; i <= 12; i++) {
                player.bettingStrategy[i] = {
                    type: DOM.bettingStrategyTable.querySelector(`select[data-spread="${i}"]`).value,
                    value: parseFloat(DOM.bettingStrategyTable.querySelector(`input[data-spread="${i}"]`).value)
                };
            }

            if(isEditing) {
                players = players.map(p => p.id === id ? player : p);
            } else {
                players.push(player);
            }
            updatePlayerColors();
            renderPlayerList();
            closePlayerModal();
        }

        function renderPlayerList() {
            DOM.playerList.innerHTML = '';
            if (players.length === 0) DOM.playerList.innerHTML = `<p class="text-gray-400">No players yet. Add one to begin.</p>`;
            players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'flex justify-between items-center bg-gray-700 p-2 rounded-lg';
                playerDiv.innerHTML = `
                    <div class="flex items-center gap-2">
                        <span class="w-4 h-4 rounded-full" style="background-color: ${playerColors[player.id]}"></span>
                        <span class="font-medium">${player.name}</span>
                    </div>
                    <div class="flex gap-2">
                        <button class="btn btn-secondary btn-sm" data-id="${player.id}">Edit</button>
                        <button class="btn btn-danger btn-sm" data-id="${player.id}">Delete</button>
                    </div>`;
                playerDiv.querySelector('button.btn-secondary').addEventListener('click', (e) => openPlayerModal(e.target.dataset.id));
                playerDiv.querySelector('button.btn-danger').addEventListener('click', (e) => {
                    players = players.filter(p => p.id !== e.target.dataset.id);
                    updatePlayerColors();
                    renderPlayerList();
                });
                DOM.playerList.appendChild(playerDiv);
            });
        }

        // --- SIMULATION HANDLING ---

        function initWorker() {
            if (simulationWorker) simulationWorker.postMessage({type: 'terminate'});
            const workerScript = document.getElementById('simulator-worker').textContent;
            const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
            simulationWorker = new Worker(URL.createObjectURL(workerBlob));
            simulationWorker.onmessage = handleWorkerMessage;
        }

        function handleWorkerMessage(e) {
            const { type, data } = e.data;
            switch(type) {
                case 'ready':
                    theoreticalStats = data.theoreticalStats;
                    break;
                case 'deckShuffled':
                    renderInitialDeck(data.deck);
                    break;
                case 'tick':
                    currentLiveGamePotHistory.push(data.latestPot);
                    Object.keys(data.playerPots).forEach(pId => {
                        if (!currentLivePlayerPotHistory[pId]) currentLivePlayerPotHistory[pId] = [];
                        currentLivePlayerPotHistory[pId].push(data.playerPots[pId]);
                    });
                    currentLivePlayerBets = data.playerBets;

                    const { latestPot, playerPots, playerBets, deck, turnDetails, ...rest } = data;
                    currentLiveGameData = rest;

                    if (deck) renderLiveDeck(deck);
                    if (turnDetails) renderLiveTurn(turnDetails);

                    redrawAllCharts();
                    break;
                case 'gameComplete':
                    allCompletedGamesData.push(data.finalStats);
                    currentLiveGameData = null;
                    currentLiveGamePotHistory = [];
                    currentLivePlayerPotHistory = {};
                    currentLivePlayerBets = {};
                    simulationTimings.push(data.finalStats.duration);
                    updateProgress(data);
                    redrawAllCharts();
                    if(DOM.liveTurnDisplay) DOM.liveTurnDisplay.innerHTML = '';
                    break;
                case 'complete':
                    finalizeSimulation();
                    break;
                case 'paused':
                    isSimulationPaused = true;
                    DOM.stopSimBtn.classList.add('hidden');
                    DOM.startSimBtn.textContent = 'Resume Simulation';
                    DOM.startSimBtn.disabled = false;
                    DOM.startSimBtn.classList.remove('hidden');
                    DOM.nextTurnBtnContainer.classList.remove('hidden');
                    DOM.nextTurnBtn.disabled = false;
                    clearInterval(simulationTimer);
                    break;
                case 'resumed':
                    isSimulationPaused = false;
                    DOM.stopSimBtn.disabled = false;
                    DOM.stopSimBtn.classList.remove('hidden');
                    DOM.startSimBtn.classList.add('hidden');
                    DOM.nextTurnBtnContainer.classList.add('hidden');
                    startTimer();
                    break;
                case 'readyForNextTurn':
                    DOM.nextTurnBtn.disabled = false;
                    break;
            }
        }

        function startOrResumeSimulation() {
            if (isSimulationPaused) {
                if (simulationWorker) {
                    simulationWorker.postMessage({ type: 'resume' });
                }
                return;
            }

            // --- Start new simulation ---
            if (players.length === 0) { alert('Please add at least one player.'); return; }

            if (DOM.configPanel.classList.contains('hidden') === false) {
                 toggleConfigPanel();
            }
            DOM.toggleConfigBtnContainer.classList.remove('hidden');
            DOM.startSimBtn.classList.add('hidden');
            DOM.stopSimBtn.disabled = false;
            DOM.stopSimBtn.classList.remove('hidden');
            DOM.resultsContainer.classList.remove('hidden');
            DOM.progressContainer.classList.remove('hidden');
            isSimulationPaused = false;
            DOM.nextTurnBtnContainer.classList.add('hidden');

            elementsToHideDuringSim.forEach(id => document.getElementById(id)?.classList.add('hidden'));

            const showDeck = DOM.showLiveDeck.checked;
            DOM.liveDeckDisplay.classList.toggle('hidden', !showDeck);
            const showTurn = DOM.showLiveTurn.checked;
            DOM.liveTurnDisplay.classList.toggle('hidden', !showTurn);

            allCompletedGamesData = []; currentLiveGameData = null; simulationTimings.length = 0; theoreticalStats = null; currentLiveGamePotHistory = []; currentLivePlayerPotHistory = {}; currentLivePlayerBets = {};

            updatePlayerColors();

            const toCents = val => Math.round(val * 100);
            const gameConfig = { ante: toCents(parseFloat(DOM.anteAmount.value)), startingPot: toCents(parseFloat(DOM.startingPot.value)), minTotalBets: parseInt(DOM.minTotalBets.value), minPotClearValue: toCents(parseFloat(DOM.minPotClearValue.value)) };
            const playersConfig = JSON.parse(JSON.stringify(players, (k,v) => v === Infinity ? "Infinity" : v)).map(p => {
                p.startMoney = toCents(p.startMoney);
                if (p.rebuy && p.rebuy.amount) p.rebuy.amount = toCents(p.rebuy.amount);
                if (p.stopLoss !== null) p.stopLoss = toCents(p.stopLoss);
                if (p.rebuy) p.rebuy.count = p.rebuy.count === "Infinity" ? Infinity : p.rebuy.count;
                return p;
            });

            const config = { players: playersConfig, game: gameConfig, simulationCount: parseInt(DOM.simCountInput.value), showLiveDeck: showDeck, showLiveTurn: showTurn };

            initWorker();
            setupPlayerWinLossCharts();
            setupPlayerBetAmountCharts();
            setupPlayerPotHistoryCharts();
            simulationStartTime = performance.now();
            updateProgress({progress: 0, gameNum: -1, totalGames: config.simulationCount});
            startTimer();
            simulationWorker.postMessage({ type: 'start', config });
        }

        function stopSimulation() {
            if (simulationWorker) {
                simulationWorker.postMessage({ type: 'stop' });
            }
        }

        function startTimer() {
            const simulationCount = parseInt(DOM.simCountInput.value);
            clearInterval(simulationTimer);
            simulationTimer = setInterval(() => {
                const elapsedSeconds = Math.round((performance.now() - simulationStartTime) / 1000);
                DOM.elapsedTimeText.textContent = `Elapsed: ${elapsedSeconds}s`;
                 if (simulationTimings.length > 0) {
                    const avgTime = simulationTimings.reduce((a, b) => a + b, 0) / simulationTimings.length;
                    const etaSeconds = Math.round(avgTime * (simulationCount - allCompletedGamesData.length));
                    DOM.etaText.textContent = `ETA: ${etaSeconds}s`;
                } else if (allCompletedGamesData.length > 0) {
                    const elapsed = (performance.now() - simulationStartTime) / 1000;
                    const timePerGame = elapsed / allCompletedGamesData.length;
                    const etaSeconds = Math.round(timePerGame * (simulationCount - allCompletedGamesData.length));
                     DOM.etaText.textContent = `ETA: ${etaSeconds}s`;
                }
            }, 1000);
        }

        function finalizeSimulation() {
            clearInterval(simulationTimer);
            DOM.startSimBtn.disabled = false;
            DOM.startSimBtn.classList.remove('hidden');
            DOM.startSimBtn.textContent = 'Start Simulation';
            DOM.stopSimBtn.disabled = true;
            DOM.stopSimBtn.classList.add('hidden');
            DOM.nextTurnBtnContainer.classList.add('hidden');
            isSimulationPaused = false;

            DOM.progressText.textContent = "Finished!";
            const elapsedSeconds = Math.round((performance.now() - simulationStartTime) / 1000);
            DOM.elapsedTimeText.textContent = `Total Time: ${elapsedSeconds}s`;
            DOM.etaText.textContent = `ETA: 0s`;
            elementsToHideDuringSim.forEach(id => document.getElementById(id)?.classList.remove('hidden'));
            redrawAllCharts(); // Final redraw to show all stats
            DOM.liveDeckDisplay.classList.add('hidden');
        }

        function updateProgress(data) {
            const { progress, gameNum, totalGames } = data;
            const percentage = Math.round(progress * 100);
            DOM.progressBar.style.width = `${percentage}%`;
            DOM.progressPercentage.textContent = `${percentage}%`;
            DOM.progressText.textContent = `Simulating game ${gameNum + 1} of ${totalGames}...`;
        }

        function redrawAllCharts() {
            if(!allCompletedGamesData.length && !currentLiveGameData) {
                 [...document.querySelectorAll('.h-96, .h-80')].forEach(el => Plotly.purge(el.id));
                return;
            }

            const isSimulating = !DOM.stopSimBtn.classList.contains('hidden') && !isSimulationPaused;

            plotPotHistoryChart(allCompletedGamesData, currentLiveGameData);
            if(theoreticalStats) updateSpreadAnalysisTable();

            if (!isSimulating) {
                plotHeatmap('game-length-heatmap', 'Game Length (# of Bets)', allCompletedGamesData.map(g => g.length), currentLiveGameData?.length);
                plotHeatmap('antes-made-heatmap', '# of Antes Made', allCompletedGamesData.map(g => g.antesMade), currentLiveGameData?.antesMade);
                plotHeatmap('shuffles-heatmap', '# of Shuffles per Game', allCompletedGamesData.map(g => g.shuffles), currentLiveGameData?.shuffles);
                plotHeatmap('game-time-heatmap', 'Game Simulation Time (s)', allCompletedGamesData.map(g => g.duration), null);

                const anyGaveUp = allCompletedGamesData.some(g => g.playersGaveUp > 0) || (currentLiveGameData && currentLiveGameData.playersGaveUp > 0);
                DOM.gaveUpHeatmapContainer.classList.toggle('hidden', !anyGaveUp);
                if (anyGaveUp) {
                    plotHeatmap('gave-up-heatmap', '# of Players Who Gave Up', allCompletedGamesData.map(g => g.playersGaveUp), currentLiveGameData?.playersGaveUp);
                }

                plotPlayerPotHistoryCharts();
                plotPlayerWinLossCharts();
                plotPlayerBetAmountCharts();
            }
        }

        function formatCard(card) {
            if (!card) return '';
            const suitSymbols = { H: '♥', D: '♦', C: '♣', S: '♠' };
            const rankSymbols = { 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: 'T', 11: 'J', 12: 'Q', 13: 'K', 14: 'A' };
            const color = (card.suit === 'H' || card.suit === 'D') ? 'text-red-400' : 'text-gray-300';
            return `<span class="${color} font-mono">${rankSymbols[card.rank]}${suitSymbols[card.suit]}</span>`;
        }

        const turnLog = [];
        let lastTurnPlayer = null;

        function renderLiveTurn(turnData) {
            const { playerName, card1, card2, spread, betAmount, card3, outcome, log, playerMoneyBefore } = turnData;

            if (lastTurnPlayer !== playerName) {
                if(turnLog.length > 0) turnLog.push(`<hr class="border-gray-600 my-2">`);
                lastTurnPlayer = playerName;
            }

            let html = `<div><b>Turn for ${playerName} ($${(playerMoneyBefore/100).toFixed(2)}):</b></div>`;

            (log || []).forEach(logEntry => {
                switch(logEntry.type) {
                    case 'rebuy':
                        html += `<div class="text-blue-400 pl-2">↪ Rebuy: +$${(logEntry.amount/100).toFixed(2)} for ${logEntry.playerName}. (${logEntry.remaining} left)</div>`;
                        break;
                    case 'stoploss':
                         html += `<div class="text-red-500 font-bold pl-2">🛑 Stop-Loss hit for ${logEntry.playerName} at $${(logEntry.threshold/100).toFixed(2)}.</div>`;
                        break;
                }
            });

            html += `<div class="pl-2">Offered: ${formatCard(card1)} ${formatCard(card2)} (Sprd: ${spread})</div>`;

            if (outcome === 'pending') {
                html += `<div class="pl-2">Betting $${(betAmount / 100).toFixed(2)}...</div>`;
            } else if (outcome === 'quit') {
                html += `<div class="text-red-500 font-bold pl-2">QUIT (can't cover bet of $${(betAmount / 100).toFixed(2)})</div>`;
            } else if (betAmount > 0) {
                let outcomeText = '';
                let outcomeColor = '';
                switch(outcome) {
                    case 'win': outcomeText = `WIN (+$${(betAmount/100).toFixed(2)})`; outcomeColor = 'text-green-400'; break;
                    case 'loss': outcomeText = `LOSS (-$${(betAmount/100).toFixed(2)})`; outcomeColor = 'text-yellow-400'; break;
                    case 'dloss': outcomeText = `D-LOSS (-$${(betAmount*2/100).toFixed(2)})`; outcomeColor = 'text-red-400'; break;
                }
                html += `<div class="pl-2">Bet $${(betAmount/100).toFixed(2)} -> Result: ${formatCard(card3)} <b class="${outcomeColor}">${outcomeText}</b></div>`;

            } else {
                html += `<div class="pl-2">Bet: $0.00 (Pass)</div>`;
            }

            turnLog.push(html);
            if (turnLog.length > 100) turnLog.shift(); // Keep log from getting too long

            DOM.liveTurnDisplay.innerHTML = turnLog.join('');
            DOM.liveTurnDisplay.scrollTop = DOM.liveTurnDisplay.scrollHeight;
        }

        function renderInitialDeck(deck) {
            let html = '<div class="mb-2"><b>Initial Deck:</b><div class="flex flex-wrap gap-1">';
            html += deck.map(formatCard).join(' ');
            html += '</div></div>';
            DOM.liveDeckDisplay.innerHTML = html;
        }

        function renderLiveDeck(deck) {
            let html = DOM.liveDeckDisplay.querySelector('.mb-2')?.outerHTML || ''; // Keep initial deck if present
            html += '<div><b>Remaining Cards:</b><div class="flex flex-wrap gap-1">';
            html += deck.map(formatCard).join(' ');
            html += '</div></div>';
            DOM.liveDeckDisplay.innerHTML = html;
        }

        // --- PLOTTING ---
        const PLOTLY_LAYOUT_CONFIG = { paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)', font: { color: '#d1d5db' }, xaxis: { gridcolor: '#374151' }, yaxis: { gridcolor: '#374151' }, margin: { l: 60, r: 20, b: 50, t: 60 } };

        function simplifyData(data, maxPoints = 1000) {
            if (!data || data.length <= maxPoints) {
                return data;
            }

            const simplified = [data[0]];
            const bucketSize = (data.length - 2) / (maxPoints - 2);

            for (let i = 0; i < maxPoints - 2; i++) {
                const bucketStartIndex = Math.floor(i * bucketSize) + 1;
                const bucketEndIndex = Math.floor((i + 1) * bucketSize) + 1;
                const bucket = data.slice(bucketStartIndex, bucketEndIndex);

                if (bucket.length === 0) continue;

                let minVal = Infinity, maxVal = -Infinity;
                for (const val of bucket) {
                    if (val < minVal) minVal = val;
                    if (val > maxVal) maxVal = val;
                }
                simplified.push(minVal);
                if (minVal !== maxVal) {
                    simplified.push(maxVal);
                }
            }

            simplified.push(data[data.length - 1]);
            return simplified;
        }

        function getHistogramData(data, numBins = 40) {
            if (!data || data.length < 1) return { centers: [], counts: [] };
            if (data.length < 2) return { centers: data, counts: data.map(() => 1) };
            const maxVal = Math.max(...data), minVal = Math.min(...data);
            if (maxVal === minVal) return { centers: [minVal], counts: [data.length] };
            const binSize = (maxVal - minVal) / numBins;
            if (binSize === 0) return { centers: [minVal], counts: [data.length] };
            const centers = []; const counts = Array(numBins).fill(0);
            for (let i = 0; i < numBins; i++) centers.push(minVal + (i + 0.5) * binSize);
            for (const value of data) {
                let binIndex = Math.floor((value - minVal) / binSize);
                if (binIndex === numBins) binIndex--;
                if (binIndex >= 0 && binIndex < numBins) counts[binIndex]++;
            }
            return { centers, counts };
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : null;
        }

        function createColorScale(hex) {
            const rgb = hexToRgb(hex);
            if (!rgb) return 'Blues';
            return [[0, `rgba(${rgb}, 0)`], [1, `rgba(${rgb}, 1)`]];
        }

        function plotPotHistoryChart(completedGames, liveGame) {
            const traces = [];

            let maxGameLength = 0;
            completedGames.forEach(game => {
                if (game.potHistory.length > maxGameLength) maxGameLength = game.potHistory.length;
            });
            if (liveGame && currentLiveGamePotHistory.length > maxGameLength) {
                maxGameLength = currentLiveGamePotHistory.length;
            }
            if (maxGameLength === 0) maxGameLength = 1;

            const layout = { ...PLOTLY_LAYOUT_CONFIG, title: 'Pot Size History', yaxis: { ...PLOTLY_LAYOUT_CONFIG.yaxis, tickprefix: '$', tickformat: ',.2f' }, xaxis: {title: 'Bet Number', range: [0, maxGameLength]}, showlegend: false };

            if (completedGames.length > 0) {
                const yBins = 50;
                const z = Array(yBins).fill(0).map(() => Array(maxGameLength).fill(0));

                let maxPot = 0;
                completedGames.forEach(game => {
                    const gameMaxPot = Math.max(...game.potHistory, 0);
                    if (gameMaxPot > maxPot) maxPot = gameMaxPot;
                });
                if (maxPot === 0) maxPot = 1;

                completedGames.forEach(game => {
                    game.potHistory.forEach((potValue, step) => {
                        const yBin = Math.min(yBins - 1, Math.floor((potValue / maxPot) * yBins));
                        if (step < maxGameLength && yBin >= 0) {
                            z[yBin][step]++;
                        }
                    });
                });

                traces.push({
                    z: z,
                    type: 'heatmap',
                    colorscale: 'Blues',
                    reversescale: true,
                    showscale: false,
                    y: Array.from({length: yBins}, (_, i) => i * (maxPot / yBins / 100)),
                    hovertemplate: 'Bet #: %{x}<br>Pot Size: ~%{y:$.2f}<br>Frequency: %{z}<extra></extra>',
                    name: 'Historical Density'
                });
            }

            if(liveGame) {
                const livePotHistory = simplifyData(currentLiveGamePotHistory.map(p => p/100));
                traces.push({
                    x: livePotHistory.map((_, i) => i),
                    y: livePotHistory,
                    mode: 'lines',
                    line: { width: 2.5, color: '#ef4444' },
                    name: `Live Pot (Game ${liveGame.gameNum})`
                });

                players.forEach(player => {
                    if (currentLivePlayerPotHistory[player.id]) {
                        const liveHistory = (currentLivePlayerPotHistory[player.id] || []).map(p => p/100);
                        traces.push({
                            x: liveHistory.map((_, i) => i),
                            y: liveHistory,
                            mode: 'lines',
                            line: { width: 1.5, color: playerColors[player.id] },
                            name: player.name
                        });
                    }
                });
            }

            Plotly.react('pot-size-chart', traces, layout, {responsive: true});
        }

        function setupPlayerPotHistoryCharts() {
            DOM.playerPotHistoryContainer.innerHTML = '';
            players.forEach(player => {
                const div = document.createElement('div');
                div.id = `player-pot-history-${player.id}`;
                div.className = 'h-96';
                DOM.playerPotHistoryContainer.appendChild(div);
            });
        }

        function plotPlayerPotHistoryCharts() {
            let maxGameLength = 0;
            allCompletedGamesData.forEach(game => {
                Object.values(game.playerPotHistory).forEach(history => {
                    if (history.length > maxGameLength) maxGameLength = history.length;
                });
            });
             if (maxGameLength === 0) maxGameLength = 1;

            players.forEach(player => {
                const yBins = 25;
                const z = Array(yBins).fill(0).map(() => Array(maxGameLength).fill(0));
                let maxPlayerPot = 0;

                allCompletedGamesData.forEach(game => {
                    const history = game.playerPotHistory[player.id] || [];
                    const gameMax = Math.max(...history, 0);
                    if (gameMax > maxPlayerPot) maxPlayerPot = gameMax;
                });
                if(maxPlayerPot === 0) maxPlayerPot = 1;

                allCompletedGamesData.forEach(game => {
                    const history = game.playerPotHistory[player.id] || [];
                    history.forEach((val, step) => {
                        const yBin = Math.min(yBins - 1, Math.floor((val / maxPlayerPot) * yBins));
                        if(step < maxGameLength && yBin >=0) z[yBin][step]++;
                    });
                });

                const trace = {
                    z: z,
                    type: 'heatmap',
                    colorscale: createColorScale(playerColors[player.id]),
                    showscale: false,
                    y: Array.from({length: yBins}, (_, i) => i * (maxPlayerPot / yBins / 100)),
                    hovertemplate: 'Bet #: %{x}<br>Pot Share: ~%{y:$.2f}<br>Frequency: %{z}<extra></extra>'
                };

                const layout = { ...PLOTLY_LAYOUT_CONFIG, title: `${player.name}: Pot Contribution History`, yaxis: { ...PLOTLY_LAYOUT_CONFIG.yaxis, tickprefix: '$' }, xaxis: {title: 'Bet Number', range: [0, maxGameLength]} };
                Plotly.react(`player-pot-history-${player.id}`, [trace], layout, {responsive: true});
            });
        }

        function setupPlayerWinLossCharts() {
            DOM.playerWinLossContainer.innerHTML = '';
            players.forEach(player => {
                const div = document.createElement('div');
                div.id = `player-win-loss-${player.id}`;
                div.className = 'h-96';
                DOM.playerWinLossContainer.appendChild(div);
            });
        }

        function plotPlayerWinLossCharts() {
            players.forEach(player => {
                const playerData = allCompletedGamesData.map(game => {
                    const financial = game.playerFinalFinancials[player.id];
                    if (!financial) return 0;
                    return (financial.finalMoney - financial.startMoney - financial.rebuyAmountUsed) / 100;
                });
                plotHeatmap(`player-win-loss-${player.id}`, `${player.name}: Win/Loss ($)`, playerData, null, '$');
            });
        }

        function setupPlayerBetAmountCharts() {
             DOM.playerBetAmountContainer.innerHTML = '';
            players.forEach(player => {
                const div = document.createElement('div');
                div.id = `player-bet-amount-${player.id}`;
                div.className = 'h-96';
                DOM.playerBetAmountContainer.appendChild(div);
            });
        }

        function plotPlayerBetAmountCharts() {
            players.forEach(player => {
                const allBets = allCompletedGamesData.flatMap(g => g.playerBets[player.id] || []).map(b => b/100);
                let liveBet = null;
                if(currentLivePlayerBets[player.id] && currentLivePlayerBets[player.id].length > 0){
                    liveBet = currentLivePlayerBets[player.id].slice(-1)[0] / 100;
                }
                plotHeatmap(`player-bet-amount-${player.id}`, `${player.name}: Bet Amounts ($)`, allBets, liveBet, '$');
            });
        }

        function plotHeatmap(elementId, title, completedData, liveValue, tickPrefix = '') {
            const { centers, counts } = getHistogramData(completedData);
            const trace = {
                x: centers, y: [''], z: [counts], type: 'heatmap',
                colorscale: [[0, 'rgba(59, 130, 246, 0.2)'], [1, 'rgba(59, 130, 246, 1)']],
                showscale: false, hoverinfo: 'x+z', hovertemplate: `Value: %{x:.2f}<br>Count: %{z}<extra></extra>`
            };
            const shapes = [];
            if (liveValue !== null && liveValue !== undefined) {
                 shapes.push({ type: 'line', yref: 'paper', x0: liveValue, x1: liveValue, y0: 0, y1: 1, line: { color: '#ef4444', width: 2, dash: 'dash' } });
            }
            const layout = { ...PLOTLY_LAYOUT_CONFIG, title, shapes, yaxis: { showticklabels: false }, xaxis: {...PLOTLY_LAYOUT_CONFIG.xaxis, tickprefix: tickPrefix} };
            Plotly.react(elementId, [trace], layout, {responsive: true});
        }


        function updateSpreadAnalysisTable() {
            const getColorStyle = (value, baseline, cap) => {
                if (baseline === 0 && value === 0) return { style: '', title: '' };
                const diff = value - baseline;
                const opacity = Math.min(1, Math.abs(diff) / cap);
                if (opacity < 0.1) return { style: '', title: `Baseline: ${baseline.toFixed(2)}` };
                const color = diff > 0 ? `rgba(0, 150, 0, ${opacity})` : `rgba(150, 0, 0, ${opacity})`;
                return {
                    style: `background-color: ${color};`,
                    title: `Baseline: ${baseline.toFixed(2)}`
                };
            };

            const allGames = [...allCompletedGamesData];
            if(currentLiveGameData) allGames.push(currentLiveGameData);

            const observed = { occurrences: Array(13).fill(0), wins: Array(13).fill(0), losses: Array(13).fill(0), dlosses: Array(13).fill(0), sumEVContextual: Array(13).fill(0), maxWins: Array(13).fill(0), sumCtxWin: Array(13).fill(0), sumCtxLoss: Array(13).fill(0), sumCtxDloss: Array(13).fill(0), sumCtxOccur: Array(13).fill(0) };
            let totalSpreads = 0;
            let totalHandsForContextual = 0;

            allGames.forEach(game => {
                totalHandsForContextual += game.totalHandsForContextual || 0;
                (game.aggregatedContextualOccurrences || []).forEach((p, i) => observed.sumCtxOccur[i] += p);
                for(const spreadKey in game.spreads) {
                    const spreadData = game.spreads[spreadKey];
                    const spreadIdx = parseInt(spreadKey);
                    if(spreadIdx >= 0 && spreadIdx <= 12 && spreadData.occurrences) {
                        const s = observed;
                        s.occurrences[spreadIdx] += spreadData.occurrences;
                        s.wins[spreadIdx] += spreadData.wins || 0;
                        s.losses[spreadIdx] += spreadData.losses || 0;
                        s.dlosses[spreadIdx] += spreadData.dlosses || 0;
                        totalSpreads += spreadData.occurrences;
                        s.sumEVContextual[spreadIdx] += spreadData.sumEVContextual || 0;
                        s.maxWins[spreadIdx] = Math.max(observed.maxWins[spreadIdx], spreadData.maxWin || 0);
                        s.sumCtxWin[spreadIdx] += spreadData.sumCtxWin || 0;
                        s.sumCtxLoss[spreadIdx] += spreadData.sumCtxLoss || 0;
                        s.sumCtxDloss[spreadIdx] += spreadData.sumCtxDloss || 0;
                    }
                }
            });

            const tbody = DOM.spreadAnalysisTable;
            tbody.innerHTML = '';

            const formatEV = (ev) => `<span class="font-mono ${ev >= 0 ? 'text-green-400' : 'text-red-400'}">${ev.toFixed(2)}</span>`;

            for (let i = 0; i <= 12; i++) {
                const totalOutcomes = observed.wins[i] + observed.losses[i] + observed.dlosses[i];
                const measuredOccurPct = totalSpreads > 0 ? (observed.occurrences[i] / totalSpreads) * 100 : 0;
                const measuredWinPct = totalOutcomes > 0 ? (observed.wins[i] / totalOutcomes) * 100 : 0;
                const measuredLossPct = totalOutcomes > 0 ? (observed.losses[i] / totalOutcomes) * 100 : 0;
                const measuredDlossPct = totalOutcomes > 0 ? (observed.dlosses[i] / totalOutcomes) * 100 : 0;
                const measuredEV = (measuredWinPct/100 * 1) + (measuredLossPct/100 * -1) + (measuredDlossPct/100 * -2);

                const contextualOccur = totalHandsForContextual > 0 ? observed.sumCtxOccur[i] / totalHandsForContextual : 0;
                const contextualWin = totalOutcomes > 0 ? observed.sumCtxWin[i] / totalOutcomes : 0;
                const contextualLoss = totalOutcomes > 0 ? observed.sumCtxLoss[i] / totalOutcomes : 0;
                const contextualDloss = totalOutcomes > 0 ? observed.sumCtxDloss[i] / totalOutcomes : 0;
                const contextualEV = observed.occurrences[i] > 0 ? (observed.sumEVContextual[i] / observed.occurrences[i]) / 100 : 0;

                const theoretical = theoreticalStats;

                const mOccurStyle = getColorStyle(measuredOccurPct, contextualOccur, 10);
                const mWinStyle = getColorStyle(measuredWinPct, contextualWin, 20);
                const mLossStyle = getColorStyle(measuredLossPct, contextualLoss, 20);
                const mDlossStyle = getColorStyle(measuredDlossPct, contextualDloss, 20);
                const mEVStyle = getColorStyle(measuredEV, contextualEV, 0.5);

                const cOccurStyle = getColorStyle(contextualOccur, theoretical.occurrence[i], 5);
                const cWinStyle = getColorStyle(contextualWin, theoretical.outcomes[i].win, 10);
                const cLossStyle = getColorStyle(contextualLoss, theoretical.outcomes[i].loss, 10);
                const cDlossStyle = getColorStyle(contextualDloss, theoretical.outcomes[i].dloss, 10);
                const cEVStyle = getColorStyle(contextualEV, theoretical.ev[i], 0.5);

                const row = document.createElement('tr'); row.className = 'border-b border-gray-600';
                row.innerHTML = `
                    <td class="px-2 py-2 font-medium border-r border-gray-600">${i}</td>
                    <td class="px-2 py-2 text-center" style="${mOccurStyle.style}" title="${mOccurStyle.title}">${measuredOccurPct.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center text-green-400" style="${mWinStyle.style}" title="${mWinStyle.title}">${measuredWinPct.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center text-yellow-400" style="${mLossStyle.style}" title="${mLossStyle.title}">${measuredLossPct.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center text-red-400" style="${mDlossStyle.style}" title="${mDlossStyle.title}">${measuredDlossPct.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center border-r border-gray-600" style="${mEVStyle.style}" title="${mEVStyle.title}">${formatEV(measuredEV)}</td>

                    <td class="px-2 py-2 text-center" style="${cOccurStyle.style}" title="${cOccurStyle.title}">${contextualOccur.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center text-green-400" style="${cWinStyle.style}" title="${cWinStyle.title}">${contextualWin.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center text-yellow-400" style="${cLossStyle.style}" title="${cLossStyle.title}">${contextualLoss.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center text-red-400" style="${cDlossStyle.style}" title="${cDlossStyle.title}">${contextualDloss.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center border-r border-gray-600" style="${cEVStyle.style}" title="${cEVStyle.title}">${formatEV(contextualEV)}</td>

                    <td class="px-2 py-2 text-center">${theoretical.occurrence[i].toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center text-green-400">${theoretical.outcomes[i].win.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center text-yellow-400">${theoretical.outcomes[i].loss.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center text-red-400">${theoretical.outcomes[i].dloss.toFixed(1)}%</td>
                    <td class="px-2 py-2 text-center">${formatEV(theoretical.ev[i])}</td>
                `;
                tbody.appendChild(row);
            }
        }

        // --- CONFIG IMPORT/EXPORT ---
        function exportConfig() {
            const config = {
                game: { ante: DOM.anteAmount.value, startingPot: DOM.startingPot.value, minTotalBets: DOM.minTotalBets.value, minPotClearValue: DOM.minPotClearValue.value },
                players: players
            };
            const jsonString = JSON.stringify(config, (key, value) => (value === Infinity ? 'Infinity' : value), 2);
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(jsonString);
            const a = document.createElement('a'); a.setAttribute("href", dataStr); a.setAttribute("download", "card_sim_config.json");
            document.body.appendChild(a); a.click(); a.remove();
        }

        function importConfig(event) {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const config = JSON.parse(e.target.result, (key, value) => (value === 'Infinity' ? Infinity : value));
                    DOM.anteAmount.value = config.game.ante;
                    DOM.startingPot.value = config.game.startingPot;
                    DOM.minTotalBets.value = config.game.minTotalBets;
                    DOM.minPotClearValue.value = config.game.minPotClearValue;
                    players = config.players;
                    updatePlayerColors();
                    renderPlayerList();
                } catch(err) { alert('Error parsing configuration file.'); console.error(err); }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // --- RUN APP ---
        initialize();
    </script>

</body>
</html>

